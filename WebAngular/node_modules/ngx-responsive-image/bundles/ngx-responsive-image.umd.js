(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/cdk/layout'), require('rxjs'), require('rxjs/operators'), require('@angular/cdk/observers'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('ngx-responsive-image', ['exports', '@angular/core', '@angular/cdk/layout', 'rxjs', 'rxjs/operators', '@angular/cdk/observers', '@angular/common'], factory) :
    (global = global || self, factory(global['ngx-responsive-image'] = {}, global.ng.core, global.ng.cdk.layout, global.rxjs, global.rxjs.operators, global.ng.cdk.observers, global.ng.common));
}(this, function (exports, core, layout, rxjs, operators, observers, common) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var BREAKPOINTS = new core.InjectionToken('BREAKPOINTS');

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_BREAKPOINTS = [
        layout.Breakpoints.XSmall,
        layout.Breakpoints.Small,
        layout.Breakpoints.Medium,
        layout.Breakpoints.Large,
        layout.Breakpoints.XLarge
    ];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_WIDTHS = [300, 600, 960, 1280, 1920];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var IMAGE_WIDTHS = new core.InjectionToken('IMAGE_WIDTHS');

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MediaService = /** @class */ (function () {
        function MediaService(breakpointObserver, breakpoints, imageWidths) {
            var _this = this;
            this.breakpointObserver = breakpointObserver;
            this.breakpoints = breakpoints;
            this.imageWidths = imageWidths;
            this.breakpoints$ = this.breakpointObserver.observe(this.breakpoints);
            this.breakpointChange$ = this.breakpoints$.pipe(operators.filter((/**
             * @param {?} breakpointState
             * @return {?}
             */
            function (breakpointState) { return breakpointState.matches; })), operators.distinctUntilChanged((/**
             * @param {?} previous
             * @param {?} current
             * @return {?}
             */
            function (previous, current) {
                return Object.keys(previous.breakpoints)[Object.values(previous.breakpoints).indexOf(true)] ===
                    Object.keys(current.breakpoints)[Object.values(current.breakpoints).indexOf(true)];
            })), operators.startWith((/** @type {?} */ (null))), operators.pairwise());
            this.breakpointUp$ = this.breakpointChange$.pipe(operators.filter((/**
             * @param {?} __0
             * @param {?} i
             * @return {?}
             */
            function (_a, i) {
                var _b = __read(_a, 2), previous = _b[0], current = _b[1];
                if (i === 0) {
                    return true;
                }
                else {
                    /** @type {?} */
                    var previousBreakpoints = Object.values(previous.breakpoints);
                    /** @type {?} */
                    var currentBreakpoints = Object.values(current.breakpoints);
                    /** @type {?} */
                    var pbi = previousBreakpoints.findIndex((/**
                     * @param {?} breakpointValue
                     * @return {?}
                     */
                    function (breakpointValue) { return breakpointValue; }));
                    /** @type {?} */
                    var cbi = currentBreakpoints.findIndex((/**
                     * @param {?} breakpointValue
                     * @return {?}
                     */
                    function (breakpointValue) { return breakpointValue; }));
                    return cbi > pbi;
                }
            })), operators.filter((/**
             * @param {?} __0
             * @return {?}
             */
            function (_a) {
                var _b = __read(_a, 2), previous = _b[0], current = _b[1];
                /** @type {?} */
                var currentBkreakpoint = Object.keys(current.breakpoints)[Object.values(current.breakpoints).indexOf(true)];
                if (!_this.maximumBreakpoint ||
                    Object.keys(current.breakpoints).indexOf(currentBkreakpoint) >
                        Object.keys(current.breakpoints).indexOf(_this.maximumBreakpoint)) {
                    _this.maximumBreakpoint = currentBkreakpoint;
                    return true;
                }
                else {
                    return false;
                }
            })), operators.map((/**
             * @param {?} __0
             * @return {?}
             */
            function (_a) {
                var _b = __read(_a, 2), previous = _b[0], current = _b[1];
                return Object.keys(current.breakpoints)[Object.values(current.breakpoints).indexOf(true)];
            })), operators.takeWhile((/**
             * @param {?} currentBreakpoint
             * @return {?}
             */
            function (currentBreakpoint) {
                return (_this.maximumBreakpoint !== _this.breakpoints[_this.breakpoints.length - 1]);
            }), true), operators.shareReplay());
            this.breakpointAndWidthUp$ = rxjs.merge(this.breakpoints$.pipe(operators.first(), operators.map((/**
             * @param {?} breakpointState
             * @return {?}
             */
            function (breakpointState) {
                return Object.keys(breakpointState.breakpoints)[Object.values(breakpointState.breakpoints).indexOf(true)];
            }))), this.breakpointUp$).pipe(operators.map((/**
             * @param {?} breakpoint
             * @return {?}
             */
            function (breakpoint) {
                return {
                    width: _this.imageWidths[_this.breakpoints.indexOf(breakpoint)],
                    breakpoint: breakpoint
                };
            })), operators.shareReplay());
        }
        MediaService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        MediaService.ctorParameters = function () { return [
            { type: layout.BreakpointObserver },
            { type: undefined, decorators: [{ type: core.Inject, args: [BREAKPOINTS,] }] },
            { type: undefined, decorators: [{ type: core.Inject, args: [IMAGE_WIDTHS,] }] }
        ]; };
        return MediaService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ResponsiveImageDirective = /** @class */ (function () {
        function ResponsiveImageDirective(platformId, element, mediaService, renderer2) {
            this.platformId = platformId;
            this.element = element;
            this.mediaService = mediaService;
            this.renderer2 = renderer2;
            this.breakpointUp = new core.EventEmitter();
            this.subscriptions = {};
        }
        /**
         * @param {?} simpleChange
         * @return {?}
         */
        ResponsiveImageDirective.prototype.ngOnChanges = /**
         * @param {?} simpleChange
         * @return {?}
         */
        function (simpleChange) {
            var _this = this;
            if (common.isPlatformBrowser(this.platformId)) {
                if (this.subscriptions.mediaSubscription) {
                    this.subscriptions.mediaSubscription.unsubscribe();
                }
                if (this.imgSrc) {
                    this.subscriptions.mediaSubscription = this.mediaService.breakpointAndWidthUp$.subscribe((/**
                     * @param {?} result
                     * @return {?}
                     */
                    function (result) {
                        if (_this.manual) {
                            _this.breakpointUp.emit({
                                imgSrc: _this.imgSrc,
                                breakpoint: result.breakpoint,
                                width: result.width
                            });
                        }
                        else {
                            _this.renderer2.setAttribute(_this.element.nativeElement, 'src', _this.imgSrc.replace(':width', result.width));
                        }
                    }));
                }
            }
        };
        /**
         * @return {?}
         */
        ResponsiveImageDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            var _this = this;
            Object.keys(this.subscriptions).forEach((/**
             * @param {?} sk
             * @return {?}
             */
            function (sk) {
                return _this.subscriptions[sk].unsubscribe();
            }));
        };
        ResponsiveImageDirective.decorators = [
            { type: core.Directive, args: [{
                        // tslint:disable-next-line: directive-selector
                        selector: 'img[responsiveImage]'
                    },] }
        ];
        /** @nocollapse */
        ResponsiveImageDirective.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] },
            { type: core.ElementRef },
            { type: MediaService },
            { type: core.Renderer2 }
        ]; };
        ResponsiveImageDirective.propDecorators = {
            imgSrc: [{ type: core.Input }],
            manual: [{ type: core.Input }],
            breakpointUp: [{ type: core.Output }]
        };
        return ResponsiveImageDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxResponsiveImageModule = /** @class */ (function () {
        function NgxResponsiveImageModule() {
        }
        /**
         * @param {?} breakpoints
         * @param {?} imageWidths
         * @return {?}
         */
        NgxResponsiveImageModule.forRoot = /**
         * @param {?} breakpoints
         * @param {?} imageWidths
         * @return {?}
         */
        function (breakpoints, imageWidths) {
            return {
                ngModule: NgxResponsiveImageModule,
                providers: [
                    {
                        provide: BREAKPOINTS,
                        useValue: breakpoints
                    },
                    {
                        provide: IMAGE_WIDTHS,
                        useValue: imageWidths
                    },
                    MediaService
                ]
            };
        };
        NgxResponsiveImageModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [ResponsiveImageDirective],
                        imports: [observers.ObserversModule, common.CommonModule],
                        exports: [ResponsiveImageDirective]
                    },] }
        ];
        return NgxResponsiveImageModule;
    }());

    exports.BREAKPOINTS = BREAKPOINTS;
    exports.DEFAULT_BREAKPOINTS = DEFAULT_BREAKPOINTS;
    exports.DEFAULT_WIDTHS = DEFAULT_WIDTHS;
    exports.IMAGE_WIDTHS = IMAGE_WIDTHS;
    exports.MediaService = MediaService;
    exports.NgxResponsiveImageModule = NgxResponsiveImageModule;
    exports.ResponsiveImageDirective = ResponsiveImageDirective;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=ngx-responsive-image.umd.js.map
