import { InjectionToken, Injectable, Inject, EventEmitter, Directive, PLATFORM_ID, ElementRef, Renderer2, Input, Output, NgModule } from '@angular/core';
import { Breakpoints, BreakpointObserver } from '@angular/cdk/layout';
import { merge } from 'rxjs';
import { filter, distinctUntilChanged, startWith, pairwise, map, takeWhile, shareReplay, first } from 'rxjs/operators';
import { ObserversModule } from '@angular/cdk/observers';
import { isPlatformBrowser, CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/cdk/layout';
const BREAKPOINTS = new InjectionToken('BREAKPOINTS');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_BREAKPOINTS = [
    Breakpoints.XSmall,
    Breakpoints.Small,
    Breakpoints.Medium,
    Breakpoints.Large,
    Breakpoints.XLarge
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_WIDTHS = [300, 600, 960, 1280, 1920];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const IMAGE_WIDTHS = new InjectionToken('IMAGE_WIDTHS');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MediaService {
    /**
     * @param {?} breakpointObserver
     * @param {?} breakpoints
     * @param {?} imageWidths
     */
    constructor(breakpointObserver, breakpoints, imageWidths) {
        this.breakpointObserver = breakpointObserver;
        this.breakpoints = breakpoints;
        this.imageWidths = imageWidths;
        this.breakpoints$ = this.breakpointObserver.observe(this.breakpoints);
        this.breakpointChange$ = this.breakpoints$.pipe(filter((/**
         * @param {?} breakpointState
         * @return {?}
         */
        breakpointState => breakpointState.matches)), distinctUntilChanged((/**
         * @param {?} previous
         * @param {?} current
         * @return {?}
         */
        (previous, current) => Object.keys(previous.breakpoints)[Object.values(previous.breakpoints).indexOf(true)] ===
            Object.keys(current.breakpoints)[Object.values(current.breakpoints).indexOf(true)])), startWith((/** @type {?} */ (null))), pairwise());
        this.breakpointUp$ = this.breakpointChange$.pipe(filter((/**
         * @param {?} __0
         * @param {?} i
         * @return {?}
         */
        ([previous, current], i) => {
            if (i === 0) {
                return true;
            }
            else {
                /** @type {?} */
                const previousBreakpoints = Object.values(previous.breakpoints);
                /** @type {?} */
                const currentBreakpoints = Object.values(current.breakpoints);
                /** @type {?} */
                const pbi = previousBreakpoints.findIndex((/**
                 * @param {?} breakpointValue
                 * @return {?}
                 */
                breakpointValue => breakpointValue));
                /** @type {?} */
                const cbi = currentBreakpoints.findIndex((/**
                 * @param {?} breakpointValue
                 * @return {?}
                 */
                breakpointValue => breakpointValue));
                return cbi > pbi;
            }
        })), filter((/**
         * @param {?} __0
         * @return {?}
         */
        ([previous, current]) => {
            /** @type {?} */
            const currentBkreakpoint = Object.keys(current.breakpoints)[Object.values(current.breakpoints).indexOf(true)];
            if (!this.maximumBreakpoint ||
                Object.keys(current.breakpoints).indexOf(currentBkreakpoint) >
                    Object.keys(current.breakpoints).indexOf(this.maximumBreakpoint)) {
                this.maximumBreakpoint = currentBkreakpoint;
                return true;
            }
            else {
                return false;
            }
        })), map((/**
         * @param {?} __0
         * @return {?}
         */
        ([previous, current]) => {
            return Object.keys(current.breakpoints)[Object.values(current.breakpoints).indexOf(true)];
        })), takeWhile((/**
         * @param {?} currentBreakpoint
         * @return {?}
         */
        currentBreakpoint => {
            return (this.maximumBreakpoint !== this.breakpoints[this.breakpoints.length - 1]);
        }), true), shareReplay());
        this.breakpointAndWidthUp$ = merge(this.breakpoints$.pipe(first(), map((/**
         * @param {?} breakpointState
         * @return {?}
         */
        breakpointState => Object.keys(breakpointState.breakpoints)[Object.values(breakpointState.breakpoints).indexOf(true)]))), this.breakpointUp$).pipe(map((/**
         * @param {?} breakpoint
         * @return {?}
         */
        breakpoint => {
            return {
                width: this.imageWidths[this.breakpoints.indexOf(breakpoint)],
                breakpoint
            };
        })), shareReplay());
    }
}
MediaService.ɵfac = function MediaService_Factory(t) { return new (t || MediaService)(ɵngcc0.ɵɵinject(ɵngcc1.BreakpointObserver), ɵngcc0.ɵɵinject(BREAKPOINTS), ɵngcc0.ɵɵinject(IMAGE_WIDTHS)); };
MediaService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: MediaService, factory: MediaService.ɵfac });
/** @nocollapse */
MediaService.ctorParameters = () => [
    { type: BreakpointObserver },
    { type: undefined, decorators: [{ type: Inject, args: [BREAKPOINTS,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [IMAGE_WIDTHS,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MediaService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.BreakpointObserver }, { type: undefined, decorators: [{
                type: Inject,
                args: [BREAKPOINTS]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [IMAGE_WIDTHS]
            }] }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ResponsiveImageDirective {
    /**
     * @param {?} platformId
     * @param {?} element
     * @param {?} mediaService
     * @param {?} renderer2
     */
    constructor(platformId, element, mediaService, renderer2) {
        this.platformId = platformId;
        this.element = element;
        this.mediaService = mediaService;
        this.renderer2 = renderer2;
        this.breakpointUp = new EventEmitter();
        this.subscriptions = {};
    }
    /**
     * @param {?} simpleChange
     * @return {?}
     */
    ngOnChanges(simpleChange) {
        if (isPlatformBrowser(this.platformId)) {
            if (this.subscriptions.mediaSubscription) {
                this.subscriptions.mediaSubscription.unsubscribe();
            }
            if (this.imgSrc) {
                this.subscriptions.mediaSubscription = this.mediaService.breakpointAndWidthUp$.subscribe((/**
                 * @param {?} result
                 * @return {?}
                 */
                result => {
                    if (this.manual) {
                        this.breakpointUp.emit({
                            imgSrc: this.imgSrc,
                            breakpoint: result.breakpoint,
                            width: result.width
                        });
                    }
                    else {
                        this.renderer2.setAttribute(this.element.nativeElement, 'src', this.imgSrc.replace(':width', result.width));
                    }
                }));
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        Object.keys(this.subscriptions).forEach((/**
         * @param {?} sk
         * @return {?}
         */
        sk => this.subscriptions[sk].unsubscribe()));
    }
}
ResponsiveImageDirective.ɵfac = function ResponsiveImageDirective_Factory(t) { return new (t || ResponsiveImageDirective)(ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MediaService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
ResponsiveImageDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ResponsiveImageDirective, selectors: [["img", "responsiveImage", ""]], inputs: { imgSrc: "imgSrc", manual: "manual" }, outputs: { breakpointUp: "breakpointUp" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
ResponsiveImageDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: ElementRef },
    { type: MediaService },
    { type: Renderer2 }
];
ResponsiveImageDirective.propDecorators = {
    imgSrc: [{ type: Input }],
    manual: [{ type: Input }],
    breakpointUp: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ResponsiveImageDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line: directive-selector
                selector: 'img[responsiveImage]'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }, { type: ɵngcc0.ElementRef }, { type: MediaService }, { type: ɵngcc0.Renderer2 }]; }, { breakpointUp: [{
            type: Output
        }], imgSrc: [{
            type: Input
        }], manual: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxResponsiveImageModule {
    /**
     * @param {?} breakpoints
     * @param {?} imageWidths
     * @return {?}
     */
    static forRoot(breakpoints, imageWidths) {
        return {
            ngModule: NgxResponsiveImageModule,
            providers: [
                {
                    provide: BREAKPOINTS,
                    useValue: breakpoints
                },
                {
                    provide: IMAGE_WIDTHS,
                    useValue: imageWidths
                },
                MediaService
            ]
        };
    }
}
NgxResponsiveImageModule.ɵfac = function NgxResponsiveImageModule_Factory(t) { return new (t || NgxResponsiveImageModule)(); };
NgxResponsiveImageModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NgxResponsiveImageModule });
NgxResponsiveImageModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[ObserversModule, CommonModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxResponsiveImageModule, [{
        type: NgModule,
        args: [{
                declarations: [ResponsiveImageDirective],
                imports: [ObserversModule, CommonModule],
                exports: [ResponsiveImageDirective]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxResponsiveImageModule, { declarations: function () { return [ResponsiveImageDirective]; }, imports: function () { return [ObserversModule, CommonModule]; }, exports: function () { return [ResponsiveImageDirective]; } }); })();

export { BREAKPOINTS, DEFAULT_BREAKPOINTS, DEFAULT_WIDTHS, IMAGE_WIDTHS, MediaService, NgxResponsiveImageModule, ResponsiveImageDirective };

//# sourceMappingURL=ngx-responsive-image.js.map